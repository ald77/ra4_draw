#! /usr/bin/env python

from __future__ import print_function

import argparse
import shutil
import errno
import os
import subprocess
import multiprocessing
import sys
import fnmatch

class DirStructure:
    def __init__(self, src, inc, make, obj, exe):
        self.src = src
        self.inc = inc
        self.make = make
        self.obj = obj
        self.exe = exe

class Term(object):
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    DARKCYAN = '\033[36m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'

def fullPath(path):
    return os.path.realpath(os.path.abspath(os.path.expanduser(path)))

def ensureDir(path):
    try:
        os.makedirs(path)
    except OSError:
        if not os.path.isdir(path):
            raise

def tryRemove(directory, pattern):
    if pattern == None:
        try: shutil.rmtree(directory)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise
        finally:
            return

    for root, dirs, files in os.walk(fullPath(directory), topdown=False):
        for f in files:
            if fnmatch.fnmatch(f, pattern):
                os.remove(os.path.join(root, f))
        try: os.rmdir(root)
        except OSError as e:
            if e.errno != errno.ENOTEMPTY:
                raise
        
def clean(dirs):
    tryRemove(".", "*~")
    tryRemove(".", "*#")
    tryRemove(dirs.exe, "*.exe")
    tryRemove(dirs.make, "*.d")
    tryRemove(dirs.obj, "*.o")
    tryRemove(dirs.obj, "*.a")
    tryRemove(dirs.inc, "baby*.hpp")
    tryRemove(dirs.src, "baby*.cpp")
    tryRemove(".", ".subdirs.mk")
    pass

def ensureSubdirs(base, subdirs):
    for subdir in subdirs:
        ensureDir(os.path.join(base, subdir))

def getSubdirs(base, subdirs):
    base = fullPath(base)
    for root, dirs, files in os.walk(base):
        if root == base: continue
        subdirs.add(os.path.relpath(root, base))
            
def genSubdirs(dirs):
    ra4_draw = os.path.dirname(fullPath(__file__))
    srcdir = fullPath(os.path.join(ra4_draw, dirs.src))
    incdir = fullPath(os.path.join(ra4_draw, dirs.inc))
    objdir = fullPath(os.path.join(ra4_draw, dirs.obj))
    makedir = fullPath(os.path.join(ra4_draw, dirs.make))
    exedir = fullPath(os.path.join(ra4_draw, dirs.exe))

    subdirs = set()
    getSubdirs(srcdir, subdirs)
    getSubdirs(incdir, subdirs)

    ensureSubdirs(srcdir, subdirs)
    ensureSubdirs(incdir, subdirs)
    ensureSubdirs(objdir, subdirs)
    ensureSubdirs(makedir, subdirs)
    ensureSubdirs(exedir, subdirs)

def build(dirs, verbosity):
    genSubdirs(dirs)
    
    command = ["make","-j",str(multiprocessing.cpu_count()),"-k","-r","-R",
               "SRCDIR="+dirs.src, "INCDIR="+dirs.inc,
               "MAKEDIR="+dirs.make, "OBJDIR="+dirs.obj, "EXEDIR="+dirs.exe]
    if verbosity < 1:
        command.append("--silent")
    elif verbosity > 1:
        command.append("--debug")
    p = subprocess.Popen(command, stderr=subprocess.PIPE)
    err_msg = p.communicate()[1]
    if p.returncode == 0:
        print("\n\n"+Term.GREEN+Term.BOLD
              +"Compilation succeeded!"
              +Term.END+Term.END+"\n")
    else:
        print("\n\n"+Term.RED+Term.BOLD
              +"################ ERRORS AND WARNINGS ################"
              +Term.END+Term.END+"\n", file=sys.stderr)
        print(err_msg.decode("utf-8"), file=sys.stderr)
        print("\n\n"+Term.RED+Term.BOLD
              +"Compilation failed."
              +Term.END+Term.END+"\n", file=sys.stderr)
        sys.exit(p.returncode)
    
def compile(do_clean, verbosity, dirs):
    if do_clean:
        clean(dirs)
    else:
        build(dirs, verbosity)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description = "Compiles ra4_draw code",
                                     formatter_class = argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("-c","--clean", action="store_true",
                        help = "Remove all files normally generated by this script instead of compiling.")
    parser.add_argument("-v","--verbosity", type=int, default=1, choices=[0,1,2],
                        help = "Set verbosity. Lower = less printing.")
    parser.add_argument("--src_dir", default = "src",
                        help = "Directory containing .cpp and .cxx files")
    parser.add_argument("--inc_dir", default = "inc",
                        help = "Directory containing .hpp files")
    parser.add_argument("--make_dir", default = "bin",
                        help = "Directory in which to store .d files")
    parser.add_argument("--obj_dir", default = "bin",
                        help = "Directory in which to place .o files")
    parser.add_argument("--exe_dir", default = "run",
                        help = "Directory in which to store .exe files")
    args = parser.parse_args()

    compile(args.clean, args.verbosity,
            DirStructure(args.src_dir, args.inc_dir, args.make_dir, args.obj_dir, args.exe_dir))
